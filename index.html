<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>K√™u L√¥ T√¥ Realtime</title>
    <style>
      :root {
        --bg1: #f3f6ff;
        --bg2: #eef2ff;
        --bg3: #e9f0ff;

        --card: rgba(255, 255, 255, 0.92);
        --card2: rgba(255, 255, 255, 0.78);

        --text: #10162f;
        --muted: #4b567a;

        --ok: #0aa66a;
        --warn: #cc8a00;
        --bad: #d12d46;

        --accent: #3b5bff;
        --accent2: #12b76a;

        --shadow: rgba(16, 22, 47, 0.12);
        --border: rgba(16, 22, 47, 0.1);
      }

      body {
        margin: 0;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial;
        background:
          radial-gradient(
            circle at 20% 0%,
            rgba(59, 91, 255, 0.16),
            transparent 45%
          ),
          radial-gradient(
            circle at 90% 20%,
            rgba(18, 183, 106, 0.12),
            transparent 45%
          ),
          linear-gradient(180deg, var(--bg1), var(--bg2) 40%, var(--bg3));
        color: var(--text);
      }
      .wrap {
        max-width: 1250px;
        margin: 0 auto;
        padding: 18px;
      }
      h1 {
        margin: 8px 0 2px;
        font-size: 20px;
      }
      .sub {
        color: var(--muted);
        margin: 0 0 14px;
        font-size: 13px;
      }
      .grid {
        display: grid;
        grid-template-columns: 430px 1fr;
        gap: 14px;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 12px 34px var(--shadow);
        backdrop-filter: blur(6px);
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      label {
        font-size: 12px;
        color: var(--muted);
      }
      input,
      select,
      button {
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(16, 22, 47, 0.04);
        color: var(--text);
        padding: 10px 12px;
        font-size: 14px;
        outline: none;
      }
      input {
        width: 100%;
        box-sizing: border-box;
      }
      button {
        cursor: pointer;
        font-weight: 700;
      }
      button.primary {
        background: rgba(59, 91, 255, 0.14);
        border-color: rgba(59, 91, 255, 0.28);
      }
      button.primary:hover {
        background: rgba(59, 91, 255, 0.18);
      }
      button.danger {
        background: rgba(209, 45, 70, 0.12);
        border-color: rgba(209, 45, 70, 0.28);
      }
      button.ghost {
        background: transparent;
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .big {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 150px;
        border-radius: 16px;
        background:
          radial-gradient(
            circle at 30% 30%,
            rgba(59, 91, 255, 0.18),
            transparent 55%
          ),
          radial-gradient(
            circle at 80% 40%,
            rgba(18, 183, 106, 0.12),
            transparent 55%
          ),
          linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.92),
            rgba(255, 255, 255, 0.78)
          );
        border: 1px solid var(--border);
        font-size: 72px;
        font-weight: 900;
        letter-spacing: 2px;
        position: relative;
        overflow: hidden;
      }
      .big .mini {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0;
        font-weight: 700;
      }

      @keyframes lotoRoll {
        0% {
          transform: translateY(-18px) scale(0.96);
          filter: blur(2px);
          opacity: 0.2;
        }
        55% {
          transform: translateY(6px) scale(1.04);
          filter: blur(0.6px);
          opacity: 1;
        }
        100% {
          transform: translateY(0) scale(1);
          filter: blur(0);
          opacity: 1;
        }
      }
      .big.roll #lastNumValue {
        animation: lotoRoll 520ms ease-out;
      }

      /* ===== Dice suspense mode (khi c√≥ ng∆∞·ªùi "ƒê·ª£i") ===== */
      .big.dice #lastNumValue {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 190px;
        padding: 10px 18px;
        border-radius: 18px;
      }

      @keyframes diceShake {
        0% {
          transform: translate(0, 0) rotate(0deg) scale(1);
          filter: blur(0);
        }
        10% {
          transform: translate(-3px, 2px) rotate(-2deg) scale(1.02);
          filter: blur(0.3px);
        }
        20% {
          transform: translate(4px, -2px) rotate(2deg) scale(1.03);
          filter: blur(0.5px);
        }
        30% {
          transform: translate(-4px, 1px) rotate(-3deg) scale(1.02);
        }
        40% {
          transform: translate(3px, -1px) rotate(3deg) scale(1.04);
        }
        50% {
          transform: translate(-2px, 2px) rotate(-2deg) scale(1.02);
          filter: blur(0.6px);
        }
        60% {
          transform: translate(2px, -2px) rotate(2deg) scale(1.03);
        }
        70% {
          transform: translate(-3px, 1px) rotate(-2deg) scale(1.02);
        }
        80% {
          transform: translate(3px, -1px) rotate(2deg) scale(1.03);
          filter: blur(0.3px);
        }
        90% {
          transform: translate(-1px, 1px) rotate(-1deg) scale(1.01);
          filter: blur(0.1px);
        }
        100% {
          transform: translate(0, 0) rotate(0deg) scale(1);
          filter: blur(0);
        }
      }

      .big.dice.rolling #lastNumValue {
        animation: diceShake 320ms linear infinite;
      }

      .big::after {
        content: "";
        position: absolute;
        inset: -40%;
        background: radial-gradient(
          circle at 50% 50%,
          rgba(255, 255, 255, 0.14),
          transparent 55%
        );
        transform: rotate(25deg);
        pointer-events: none;
      }

      .big .quick {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        display: none;
        justify-content: center;
        gap: 10px;
      }

      .status {
        margin-top: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        color: var(--muted);
        font-size: 12px;
      }
      .pill {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(16, 22, 47, 0.03);
        font-weight: 700;
      }
      .pill.ok {
        border-color: rgba(10, 166, 106, 0.28);
        background: rgba(10, 166, 106, 0.1);
        color: #0a5b3e;
      }
      .pill.warn {
        border-color: rgba(204, 138, 0, 0.28);
        background: rgba(204, 138, 0, 0.1);
        color: #6b4b00;
      }
      .pill.bad {
        border-color: rgba(209, 45, 70, 0.28);
        background: rgba(209, 45, 70, 0.1);
        color: #7a1324;
      }

      .nums {
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        gap: 6px;
      }
      .nums {
        background: rgba(255, 255, 255, 0.55);
        padding: 10px;
        border-radius: 14px;
        border: 1px solid var(--border);
      }
      .n {
        text-align: center;
        padding: 8px 0;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(16, 22, 47, 0.03);
        font-variant-numeric: tabular-nums;
        user-select: none;
        font-weight: 800;
        color: #1b244b;
      }
      .n.called {
        background: linear-gradient(
          180deg,
          rgba(18, 183, 106, 0.32),
          rgba(18, 183, 106, 0.14)
        );
        border-color: rgba(18, 183, 106, 0.55);
        color: #0b2a1d;
        font-weight: 900;
        text-shadow: 0 1px 0 rgba(255, 255, 255, 0.4);
      }
      .n.last {
        outline: 3px solid rgba(255, 204, 102, 0.95);
        box-shadow: 0 0 0 3px rgba(255, 204, 102, 0.16);
      }

      .split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }
      @media (max-width: 980px) {
        .split {
          grid-template-columns: 1fr;
        }
      }

      .ticket {
        display: grid;
        gap: 8px;
        margin-top: 10px;
      }
      .tcell {
        padding: 12px 0;
        text-align: center;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(16, 22, 47, 0.03);
        font-weight: 900;
        font-variant-numeric: tabular-nums;
        user-select: none;
        color: #1b244b;
      }
      .tcell.called {
        background: linear-gradient(
          180deg,
          rgba(18, 183, 106, 0.22),
          rgba(18, 183, 106, 0.08)
        );
        box-shadow: inset 0 0 0 2px rgba(18, 183, 106, 0.48);
        color: #0b2a1d;
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
        margin-top: 10px;
        line-height: 1.45;
      }
      .small {
        font-size: 12px;
        color: var(--muted);
      }
      .hr {
        height: 1px;
        background: rgba(16, 22, 47, 0.1);
        margin: 12px 0;
      }
      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      /* Winner overlay */
      #winnerOverlay {
        position: fixed;
        inset: 0;
        display: none;
        background: rgba(16, 22, 47, 0.55);
        align-items: center;
        justify-content: center;
        z-index: 9999;
        padding: 18px;
      }
      .winnerBox {
        width: min(600px, 100%);
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.22);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.96),
          rgba(255, 255, 255, 0.9)
        );
        box-shadow: 0 20px 60px rgba(16, 22, 47, 0.35);
        padding: 16px;
        text-align: center;
      }
      .winnerTitle {
        font-size: 44px;
        font-weight: 1000;
        margin: 8px 0 2px;
        color: #8a5a00;
      }
      .winnerSub {
        color: var(--muted);
        margin: 0 0 10px;
        font-weight: 700;
      }
      .winnerName {
        font-size: 22px;
        font-weight: 1000;
        margin: 6px 0 10px;
      }
      .winnerHint {
        color: var(--muted);
        font-size: 13px;
        line-height: 1.5;
        margin-top: 8px;
      }

      /* All tickets viewer */
      .ticketsGrid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 10px;
      }
      @media (max-width: 980px) {
        .ticketsGrid {
          grid-template-columns: 1fr;
        }
      }
      .pCard {
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.75);
        padding: 10px;
      }
      .pHead {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 8px;
        font-weight: 700;
      }
      .pName {
        color: var(--text);
        font-weight: 1000;
        font-size: 14px;
      }

      #topJoinBar {
        top: 10px;
        z-index: 20;
        padding: 10px 12px !important;
        margin: 0 0 12px 0;

        border-radius: 16px;
        background:
          radial-gradient(
            circle at 10% 20%,
            rgba(59, 91, 255, 0.12),
            transparent 48%
          ),
          radial-gradient(
            circle at 85% 30%,
            rgba(18, 183, 106, 0.1),
            transparent 55%
          ),
          linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.96),
            rgba(255, 255, 255, 0.88)
          );
      }

      #topJoinBar .row {
        gap: 10px !important;
        align-items: end !important;
      }

      /* Nh√≥m input g·ªçn nh∆∞ toolbar */
      #topJoinBar .tbGroup {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      #topJoinBar label {
        font-size: 11px;
        letter-spacing: 0.2px;
        color: rgba(16, 22, 47, 0.62);
        font-weight: 800;
      }

      #topJoinBar input {
        height: 38px;
        padding: 0 12px !important;
        border-radius: 14px !important;
        border: 1px solid rgba(16, 22, 47, 0.12) !important;
        background: rgba(255, 255, 255, 0.72) !important;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.4);
      }

      #topJoinBar input:focus {
        border-color: rgba(59, 91, 255, 0.35) !important;
        box-shadow:
          0 0 0 4px rgba(59, 91, 255, 0.12),
          inset 0 0 0 1px rgba(255, 255, 255, 0.55);
      }

      /* N√∫t toolbar */
      #topJoinBar button {
        height: 38px;
        padding: 0 12px !important;
        border-radius: 14px !important;
        font-weight: 900;
        border: 1px solid rgba(16, 22, 47, 0.12);
        background: rgba(255, 255, 255, 0.64);
      }

      #topJoinBar button.primary {
        background: linear-gradient(
          180deg,
          rgba(59, 91, 255, 0.18),
          rgba(59, 91, 255, 0.12)
        ) !important;
        border-color: rgba(59, 91, 255, 0.28) !important;
      }

      #topJoinBar button.primary:hover {
        background: linear-gradient(
          180deg,
          rgba(59, 91, 255, 0.22),
          rgba(59, 91, 255, 0.14)
        ) !important;
      }

      #topJoinBar button.ghost {
        background: rgba(16, 22, 47, 0.03) !important;
      }
      #topJoinBar button.ghost:hover {
        background: rgba(16, 22, 47, 0.06) !important;
      }

      #topJoinBar button:disabled {
        opacity: 0.55;
      }

      /* Pill tr·∫°ng th√°i n·∫±m g·ªçn b√™n ph·∫£i */
      #topJoinBar #connPill {
        height: 32px;
        display: inline-flex;
        align-items: center;
        padding: 0 12px;
        border-radius: 999px;
        margin-left: auto !important;
        white-space: nowrap;
      }

      /* L∆∞u √Ω nh·ªè g·ªçn */
      #topJoinBar .tbNote {
        margin-top: 8px;
        font-size: 12px;
        color: rgba(16, 22, 47, 0.62);
        font-weight: 700;
      }

      #topJoinBar .tbNote .mono {
        font-weight: 900;
      }

      /* Mobile: t·ª± xu·ªëng d√≤ng ƒë·∫πp */
      @media (max-width: 720px) {
        #topJoinBar {
          top: 6px;
        }
        #topJoinBar .row {
          gap: 8px !important;
        }
        #topJoinBar .tbRoom input {
          width: 130px !important;
        }
        #topJoinBar .tbName {
          flex: 1 1 100%;
        }
        #topJoinBar #connPill {
          order: 99;
          margin-left: 0 !important;
        }
      }

      /* ===== Role-based accents ===== */
      body.role-player .big {
        border-color: rgba(18, 183, 106, 0.35);
      }
      body.role-mc .big {
        border-color: rgba(59, 91, 255, 0.45);
      }
      body.role-viewer .big {
        border-color: rgba(204, 138, 0, 0.35);
      }
      body.role-mcplayer .big {
        border-color: rgba(59, 91, 255, 0.45);
        box-shadow: 0 16px 44px rgba(59, 91, 255, 0.14);
      }
    </style>

    <!-- Firebase (compat) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  </head>
  <body>
    <!-- KINH overlay -->
    <div id="winnerOverlay">
      <div class="winnerBox">
        <div class="winnerTitle">KINH!</div>
        <p class="winnerSub">V√°n ƒë√£ d·ª´ng.</p>
        <div class="winnerName" id="winnerName">‚Äî</div>

        <div class="hr"></div>
        <div class="small" style="text-align: left; margin-top: 6px">
          <b>Ng∆∞·ªùi thua:</b>
        </div>
        <div
          class="small"
          id="nonWinnerList"
          style="text-align: left; white-space: pre-line; margin-top: 6px"
        >
          ‚Äî
        </div>

        <div class="row" style="justify-content: center; margin-top: 10px">
          <button id="btnOverlayNewRound" class="primary">
            B·∫Øt ƒë·∫ßu v√°n m·ªõi
          </button>
          <button id="btnOverlayClose" class="ghost">ƒê√≥ng</button>
        </div>

        <div class="winnerHint" id="winnerHint">
          MC b·∫•m ‚ÄúB·∫Øt ƒë·∫ßu v√°n m·ªõi‚Äù ƒë·ªÉ chuy·ªÉn sang <b>CH·ªú</b> (m·ªçi ng∆∞·ªùi ƒë·ªïi/t·∫°o
          v√©), sau ƒë√≥ b·∫•m <b>B·∫Øt ƒë·∫ßu ch∆°i</b>.
        </div>
      </div>
    </div>

    <div class="wrap">
      <h1>üé≤ K√™u L√¥ T√¥ Realtime</h1>
      <p class="sub">
        C√≥ tr·∫°ng th√°i CH·ªú ƒë·ªÉ ƒë·ªïi v√©. KINH xong chuy·ªÉn v·ªÅ CH·ªú. Ch·ªâ ng∆∞·ªùi ch∆∞a c√≥
        v√© m·ªõi th·∫•y ‚ÄúAll v√©‚Äù.
      </p>
      <div class="card" id="topJoinBar">
        <div class="row">
          <div class="tbGroup tbRoom" style="min-width: 140px">
            <label>M√£ ph√≤ng</label>
            <input id="roomId" placeholder="482913" style="width: 150px" />
          </div>

          <button id="btnCreate" class="ghost" title="T·∫°o m√£ ph√≤ng ng·∫´u nhi√™n">
            üé≤
          </button>

          <div class="tbGroup tbName" style="flex: 1; min-width: 180px">
            <label>T√™n</label>
            <input id="playerName" placeholder="T√™n c·ªßa b·∫°n" maxlength="24" />
          </div>

          <button id="btnJoin" class="primary">V√†o</button>
          <button id="btnLeave" class="ghost" disabled>R·ªùi</button>

          <div class="pill" id="connPill">Ch∆∞a v√†o ph√≤ng</div>
        </div>
      </div>

      <div class="grid">
        <!-- LEFT -->
        <div class="card">
          <!-- MC SECTION (lu√¥n hi·ªÉn th·ªã) -->
          <div id="mcSection">
            <!-- MC RIGHTS -->
            <div>
              <div style="font-weight: 1000">Quy·ªÅn MC</div>
              <div class="small" id="mcInfo" style="margin-top: 6px">
                Ch∆∞a v√†o ph√≤ng
              </div>

              <div class="row" style="margin-top: 10px">
                <button id="btnClaimMC" class="primary" disabled>
                  Nh·∫≠n quy·ªÅn MC
                </button>
                <button id="btnReleaseMC" class="ghost" disabled>
                  Nh∆∞·ªùng quy·ªÅn MC
                </button>
              </div>

              <div id="transferWrap" style="margin-top: 10px; display: none">
                <div class="row">
                  <select
                    id="transferTo"
                    style="flex: 1; min-width: 200px"
                  ></select>
                  <button id="btnTransferMC" class="primary">Trao quy·ªÅn</button>
                </div>
                <div class="hint">Ch·ªâ MC hi·ªán t·∫°i m·ªõi trao quy·ªÅn ƒë∆∞·ª£c.</div>
              </div>
              <div class="hr"></div>
            </div>

            <!-- MC PANEL -->
            <div>
              <div style="font-weight: 1000">B·∫£ng ƒëi·ªÅu khi·ªÉn MC</div>

              <div class="row" style="margin-top: 10px">
                <div style="flex: 1; min-width: 180px">
                  <label>K√≠ch th∆∞·ªõc v√© (ch·ªâ khi CH·ªú)</label><br />
                  <select id="ticketSize" disabled>
                    <option value="5x5">5 x 5</option>
                    <option value="9x5">9 x 5</option>
                  </select>
                </div>
              </div>

              <div class="row" style="margin-top: 10px">
                <button id="btnNewRound" class="primary" disabled>
                  B·∫Øt ƒë·∫ßu v√°n m·ªõi
                </button>
                <button id="btnStartPlay" class="primary" disabled>
                  B·∫Øt ƒë·∫ßu ch∆°i
                </button>
              </div>

              <div class="row" style="margin-top: 10px">
                <button id="btnDraw" class="primary" disabled>K√™u s·ªë</button>
                <button id="btnUndo" class="ghost" disabled>L√πi 1 s·ªë</button>
                <button id="btnResetRoom" class="danger" disabled>
                  Xo√° ph√≤ng
                </button>
              </div>

              <div class="row" style="margin-top: 10px">
                <label class="small"
                  ><input type="checkbox" id="chkSpeak" checked /> ƒê·ªçc s·ªë</label
                >
                <label class="small"
                  ><input type="checkbox" id="chkLock" /> T·∫°m kho√° k√™u s·ªë</label
                >
                <label class="small"
                  ><input type="checkbox" id="chkAuto" /> T·ª± ƒë·ªông k√™u</label
                >
                <label class="small"
                  >M·ªói
                  <input
                    id="autoSec"
                    type="number"
                    min="1"
                    max="30"
                    value="5"
                    style="width: 72px; padding: 8px 10px; border-radius: 10px"
                  />
                  gi√¢y</label
                >
                <label class="small"
                  >Ch·∫≠m th√™m khi ‚Äúƒê·ª£i‚Äù
                  <input
                    id="slowExtraSec"
                    type="number"
                    min="0"
                    max="60"
                    value="3"
                    style="width: 72px; padding: 8px 10px; border-radius: 10px"
                  />
                  gi√¢y</label
                >
              </div>

              <div class="hint" id="phaseHint">‚Äî</div>
            </div>
            <div class="hr"></div>
          </div>

          <!-- PLAYER TICKET -->
          <div>
            <div style="font-weight: 1000">V√© c·ªßa b·∫°n</div>
            <div class="small" id="myTicketInfo" style="margin-top: 6px">‚Äî</div>

            <div
              class="row"
              style="justify-content: space-between; margin-top: 10px"
            >
              <button id="btnNewTicket" class="primary" disabled>
                T·∫°o / ƒê·ªïi v√©
              </button>
              <button id="btnClearMarks" class="ghost" disabled>
                Xo√° ƒë√°nh d·∫•u
              </button>
            </div>

            <div class="hint">
              Ch·ªâ t·∫°o/ƒë·ªïi v√© khi <b>CH·ªú</b>. Khi <b>ƒêANG CH∆†I</b>, ng∆∞·ªùi c√≥ v√©
              s·∫Ω kh√¥ng th·∫•y v√© ng∆∞·ªùi kh√°c.
            </div>

            <div id="ticketWrap" style="display: none">
              <div class="ticket" id="ticket"></div>
              <div id="winMsg" class="hint"></div>
            </div>
          </div>
        </div>

        <!-- RIGHT -->
        <div class="card">
          <div class="split">
            <div>
              <div class="big" id="bigBox">
                <div class="mini" id="phaseMini">‚Äî</div>
                <span id="lastNumValue">‚Äî</span>
                <div class="quick" id="mcQuickBar">
                  <button id="btnQuickNewRound" class="primary">
                    B·∫Øt ƒë·∫ßu v√°n m·ªõi
                  </button>
                </div>
              </div>

              <div class="status">
                <div class="pill" id="connPill">Ch∆∞a v√†o ph√≤ng</div>
                <div class="pill" id="phasePill">Tr·∫°ng th√°i: ‚Äî</div>
                <div class="pill" id="rolePill">Vai tr√≤: ‚Äî</div>
                <div class="pill" id="countPill">ƒê√£ k√™u: 0/90</div>
                <div class="pill warn" id="lockPill" style="display: none">
                  ƒêang kho√°
                </div>
                <div class="pill ok" id="playersPill">Ng∆∞·ªùi ch∆°i: 0</div>
                <div class="pill warn" id="waitPill" style="display: none">
                  C√≥ ng∆∞·ªùi ƒê·ª£i
                </div>
              </div>

              <div class="hint" id="roomInfo"></div>

              <div class="hr"></div>
              <div style="font-weight: 1000">Danh s√°ch trong ph√≤ng</div>
              <div class="small" id="playersList" style="margin-top: 6px">
                ‚Äî
              </div>
            </div>

            <div>
              <div style="font-weight: 1000">B·∫£ng 1‚Äì90</div>
              <div class="small">S·ªë ƒë√£ k√™u t√¥ xanh, s·ªë m·ªõi nh·∫•t vi·ªÅn v√†ng.</div>
              <div style="margin-top: 10px" class="nums" id="board"></div>
            </div>
          </div>

          <div class="hr"></div>
          <div class="small">L·ªãch s·ª≠ (m·ªõi nh·∫•t b√™n ph·∫£i):</div>
          <div
            id="history"
            class="row"
            style="margin-top: 8px; gap: 6px; flex-wrap: wrap"
          ></div>

          <div class="hr"></div>

          <!-- ALL TICKETS (ch·ªâ hi·ªán cho ng∆∞·ªùi CH∆ØA C√ì V√â h·ª£p l·ªá) -->
          <div id="allTicketsPanel" style="display: none">
            <div style="font-weight: 1000">
              All v√© (ch·ªâ d√†nh cho ng∆∞·ªùi ch∆∞a c√≥ v√©)
            </div>
            <div class="small" id="allTicketsHint" style="margin-top: 6px">
              ‚Äî
            </div>
            <div class="ticketsGrid" id="allTickets"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      /* =======================
   1) D√ÅN firebaseConfig ·ªû ƒê√ÇY
   ======================= */
      const firebaseConfig = {
        apiKey: "AIzaSyAQgtLBcX1LBY8xgBMAvuAVB9ll3pXRMAY",
        authDomain: "tuv0-8cce5.firebaseapp.com",
        databaseURL:
          "https://tuv0-8cce5-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "tuv0-8cce5",
        storageBucket: "tuv0-8cce5.firebasestorage.app",
        messagingSenderId: "375419013161",
        appId: "1:375419013161:web:384d907409ee82020d7438",
      };

      /* =======================
   2) APP LOGIC
   ======================= */
      let app, db;
      let roomId = "";
      let roomRef = null;

      const $ = (id) => document.getElementById(id);

      const roomInput = $("roomId");
      const nameInput = $("playerName");

      const connPill = $("connPill");
      const phasePill = $("phasePill");
      const rolePill = $("rolePill");
      const countPill = $("countPill");
      const lockPill = $("lockPill");
      const playersPill = $("playersPill");
      const waitPill = $("waitPill");
      const lastNumValue = $("lastNumValue");
      const roomInfo = $("roomInfo");
      const boardEl = $("board");
      const historyEl = $("history");
      const playersListEl = $("playersList");

      const btnCreate = $("btnCreate");
      const btnJoin = $("btnJoin");
      const btnLeave = $("btnLeave");

      const mcInfo = $("mcInfo");
      const btnClaimMC = $("btnClaimMC");
      const btnReleaseMC = $("btnReleaseMC");
      const transferWrap = $("transferWrap");
      const transferTo = $("transferTo");
      const btnTransferMC = $("btnTransferMC");
      const mcSection = $("mcSection");

      const ticketSizeSel = $("ticketSize");
      const btnNewRound = $("btnNewRound");
      const btnStartPlay = $("btnStartPlay");
      const btnDraw = $("btnDraw");
      const btnUndo = $("btnUndo");
      const btnResetRoom = $("btnResetRoom");
      const chkSpeak = $("chkSpeak");
      const chkLock = $("chkLock");
      const chkAuto = $("chkAuto");
      const autoSec = $("autoSec");
      const slowExtraSec = $("slowExtraSec");
      const phaseHint = $("phaseHint");

      const myTicketInfo = $("myTicketInfo");
      const btnNewTicket = $("btnNewTicket");
      const btnClearMarks = $("btnClearMarks");
      const ticketWrap = $("ticketWrap");
      const ticketEl = $("ticket");
      const winMsg = $("winMsg");

      const phaseMini = $("phaseMini");
      const mcQuickBar = $("mcQuickBar");
      const btnQuickNewRound = $("btnQuickNewRound");

      const winnerOverlay = $("winnerOverlay");
      const winnerNameEl = $("winnerName");
      const nonWinnerListEl = $("nonWinnerList");
      const btnOverlayNewRound = $("btnOverlayNewRound");
      const btnOverlayClose = $("btnOverlayClose");

      const allTicketsPanel = $("allTicketsPanel");
      const allTicketsHint = $("allTicketsHint");
      const allTicketsEl = $("allTickets");

      const playerIdKey = "loto_playerId_v4";
      let playerId = localStorage.getItem(playerIdKey);
      if (!playerId) {
        playerId =
          crypto?.randomUUID?.() || "p" + Math.random().toString(16).slice(2);
        localStorage.setItem(playerIdKey, playerId);
      }

      let playerRef = null;
      let heartbeatTimer = null;

      let isMC = false;
      let lastWinSpokenAt = 0;
      let lastSpokenKey = null;
      let lastSpokenText = "";
      let lastSpokenAt = 0;
      let autoTimer = null;
      let autoPlanKey = "";

      let diceTimer = null;

      function startDiceRoll(finalNumber, durationMs = 1400) {
        if (diceTimer) {
          clearInterval(diceTimer);
          diceTimer = null;
        }
        const bigBox = $("bigBox");
        bigBox.classList.add("rolling");

        const start = Date.now();
        diceTimer = setInterval(() => {
          const t = Date.now() - start;
          const r = 1 + Math.floor(Math.random() * 90);
          lastNumValue.textContent = String(r).padStart(2, "0");

          if (t >= durationMs) {
            clearInterval(diceTimer);
            diceTimer = null;
            bigBox.classList.remove("rolling");
            lastNumValue.textContent = String(finalNumber).padStart(2, "0");
          }
        }, 60);
      }

      let localTicket = { ticket: [], marked: [], meta: null }; // meta: {roundId, rows, cols}
      let marked = new Set();

      function safeInitFirebase() {
        try {
          if (
            !firebaseConfig ||
            !firebaseConfig.apiKey ||
            !firebaseConfig.databaseURL
          ) {
            throw new Error(
              "Thi·∫øu firebaseConfig.apiKey ho·∫∑c firebaseConfig.databaseURL",
            );
          }
          if (!firebase.apps?.length)
            app = firebase.initializeApp(firebaseConfig);
          db = firebase.database();
          return true;
        } catch (e) {
          alert(
            "Ch∆∞a c·∫•u h√¨nh Firebase!\n\nH√£y d√°n firebaseConfig trong file.\n\nChi ti·∫øt: " +
              e.message,
          );
          console.error(e);
          return false;
        }
      }

      function genRoomId() {
        return String(Math.floor(100000 + Math.random() * 900000));
      }

      function setConnectedUI(ok, msg) {
        connPill.textContent = msg;
        connPill.className = "pill " + (ok ? "ok" : "");
      }

      function renderBoard(calledSet, last) {
        boardEl.innerHTML = "";
        for (let i = 1; i <= 90; i++) {
          const d = document.createElement("div");
          d.className =
            "n" +
            (calledSet.has(i) ? " called" : "") +
            (last === i ? " last" : "");
          d.textContent = i;
          boardEl.appendChild(d);
        }
      }

      function renderHistory(calledArr) {
        historyEl.innerHTML = "";
        const show = calledArr.slice(-30);
        show.forEach((n) => {
          const s = document.createElement("div");
          s.className = "pill ok";
          s.style.padding = "6px 10px";
          s.textContent = n;
          historyEl.appendChild(s);
        });
      }

      function readNumberVN(n) {
        const ones = [
          "kh√¥ng",
          "m·ªôt",
          "hai",
          "ba",
          "b·ªën",
          "nƒÉm",
          "s√°u",
          "b·∫£y",
          "t√°m",
          "ch√≠n",
        ];
        if (n < 10) return ones[n];
        if (n < 20) {
          if (n === 10) return "m∆∞·ªùi";
          if (n === 15) return "m∆∞·ªùi lƒÉm";
          if (n === 11) return "m∆∞·ªùi m·ªôt";
          return "m∆∞·ªùi " + ones[n % 10];
        }
        const tens = Math.floor(n / 10);
        const unit = n % 10;
        let res = ones[tens] + " m∆∞∆°i";
        if (unit === 0) return res;
        if (unit === 1) return res + " m·ªët";
        if (unit === 4) return res + " t∆∞";
        if (unit === 5) return res + " lƒÉm";
        return res + " " + ones[unit];
      }

      function speak(text) {
        try {
          if (!("speechSynthesis" in window)) return;

          const now = Date.now();
          // ch·ªëng ƒë·ªçc l·∫∑p nhanh
          if (text === lastSpokenText && now - lastSpokenAt < 800) return;
          lastSpokenText = text;
          lastSpokenAt = now;

          const u = new SpeechSynthesisUtterance(text);
          u.lang = "vi-VN";

          if (
            window.speechSynthesis.speaking ||
            window.speechSynthesis.pending
          ) {
            window.speechSynthesis.cancel();
          }

          setTimeout(() => {
            try {
              window.speechSynthesis.speak(u);
            } catch {}
          }, 40);
        } catch {}
      }

      /* ===== Ticket local + DB ===== */
      function localTicketKey() {
        return "loto_ticket_" + roomId + "_" + playerId;
      }

      function loadTicketLocal() {
        const raw = localStorage.getItem(localTicketKey());
        if (!raw) return false;
        try {
          const obj = JSON.parse(raw);
          if (!obj) return false;
          localTicket = obj;
          marked = new Set(obj.marked || []);
          return true;
        } catch {
          return false;
        }
      }

      function saveTicketLocal() {
        localStorage.setItem(
          localTicketKey(),
          JSON.stringify({
            ticket: localTicket.ticket || [],
            marked: Array.from(marked),
            meta: localTicket.meta || null,
          }),
        );
      }

      async function saveTicketToDB(ticket, meta) {
        if (!playerRef) return;
        await playerRef.update({
          ticket,
          ticketRoundId: meta.roundId,
          ticketRows: meta.rows,
          ticketCols: meta.cols,
          lastSeenAt: Date.now(),
        });
      }

      function generateTicket(rows, cols) {
        const total = rows * cols;
        const nums = [];
        const used = new Set();
        while (nums.length < total) {
          const n = 1 + Math.floor(Math.random() * 90);
          if (!used.has(n)) {
            used.add(n);
            nums.push(n);
          }
        }
        return nums;
      }

      function isValidTicketForRound(me, game) {
        const rows = game.ticketRows || 5;
        const cols = game.ticketCols || 5;
        const roundId = game.roundId || 0;

        if (!me) return false;
        if (!Array.isArray(me.ticket) || me.ticket.length !== rows * cols)
          return false;
        if (me.ticketRoundId !== roundId) return false;
        if (me.ticketRows !== rows || me.ticketCols !== cols) return false;
        return true;
      }

      function hasAnyFullRow(ticketArr, rows, cols, calledSet) {
        for (let r = 0; r < rows; r++) {
          let ok = true;
          for (let c = 0; c < cols; c++) {
            const n = ticketArr[r * cols + c];
            if (!calledSet.has(n)) {
              ok = false;
              break;
            }
          }
          if (ok) return true;
        }
        return false;
      }

      function isOneAwayRow(ticketArr, rows, cols, calledSet) {
        for (let r = 0; r < rows; r++) {
          let miss = 0;
          for (let c = 0; c < cols; c++) {
            const n = ticketArr[r * cols + c];
            if (!calledSet.has(n)) miss++;
            if (miss > 1) break;
          }
          if (miss === 1) return true;
        }
        return false;
      }

      function anyPlayerNearWin(game, playersObj, calledSet) {
        const rows = game.ticketRows || 5;
        const cols = game.ticketCols || 5;
        const players = playersObj ? Object.values(playersObj) : [];
        for (const p of players) {
          if (!p || !p.name) continue;
          if (!isValidTicketForRound(p, game)) continue;
          if (
            Array.isArray(p.ticket) &&
            isOneAwayRow(p.ticket, rows, cols, calledSet)
          )
            return true;
        }
        return false;
      }

      function clearAutoTimer() {
        if (autoTimer) {
          clearTimeout(autoTimer);
          autoTimer = null;
        }
      }

      function scheduleAutoDraw(game, playersObj, calledSet) {
        if (!isMC) return clearAutoTimer();

        const enabled = !!chkAuto?.checked;
        const phase = game.phase || "waiting";
        const locked = !!game.locked;
        const hasWinner = !!game.winner;

        if (!enabled || phase !== "playing" || locked || hasWinner)
          return clearAutoTimer();

        const base = Math.max(1, Math.min(30, Number(autoSec?.value) || 5));
        const extra = Math.max(
          0,
          Math.min(60, Number(slowExtraSec?.value) || 0),
        );
        const near = anyPlayerNearWin(game, playersObj, calledSet);
        const delaySec = near ? base + extra : base;

        const planKey = `${game.roundId || 0}|${game.last || 0}|${delaySec}|${near ? 1 : 0}`;
        if (planKey === autoPlanKey && autoTimer) return;
        autoPlanKey = planKey;

        clearAutoTimer();
        autoTimer = setTimeout(async () => {
          autoTimer = null;
          await drawNumber();
        }, delaySec * 1000);
      }

      function renderMyTicket(game, me, calledSet) {
        const rows = game.ticketRows || 5;
        const cols = game.ticketCols || 5;
        const roundId = game.roundId || 0;

        const phase = game.phase || "waiting";
        const canEdit = phase === "waiting";

        const meHasValid = isValidTicketForRound(me, game);

        if (!meHasValid) {
          ticketWrap.style.display = "none";
          if (isMC) {
            myTicketInfo.textContent = canEdit
              ? `B·∫°n ƒëang l√† MC v√† ch∆∞a c√≥ v√© cho v√°n n√†y (Round ${roundId}). N·∫øu mu·ªën v·ª´a l√†m MC v·ª´a ch∆°i, h√£y b·∫•m ‚ÄúT·∫°o / ƒê·ªïi v√©‚Äù tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu ch∆°i.`
              : `B·∫°n ƒëang l√† MC (Round ${roundId}) v√† kh√¥ng c√≥ v√© h·ª£p l·ªá. B·∫°n ƒëang ƒëi·ªÅu khi·ªÉn v√°n ch∆°i.`;
          } else {
            myTicketInfo.textContent = canEdit
              ? `B·∫°n ch∆∞a c√≥ v√© h·ª£p l·ªá cho v√°n n√†y (Round ${roundId}). H√£y b·∫•m ‚ÄúT·∫°o / ƒê·ªïi v√©‚Äù.`
              : `B·∫°n ƒëang xem (Round ${roundId}) v√¨ kh√¥ng c√≥ v√© h·ª£p l·ªá cho v√°n n√†y.`;
          }
          btnClearMarks.disabled = true;
          return;
        }

        myTicketInfo.textContent = `V√© h·ª£p l·ªá (Round ${roundId}) ‚Ä¢ K√≠ch th∆∞·ªõc: ${rows}x${cols} ‚Ä¢ B·∫°n ƒëang ${phase === "playing" ? "ch∆°i" : "ch·ªù"}.`;
        btnClearMarks.disabled = !canEdit;

        ticketWrap.style.display = "block";
        ticketEl.innerHTML = "";
        ticketEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

        const ticketArr = me.ticket;

        ticketArr.forEach((n, idx) => {
          const cell = document.createElement("div");
          const isCalled = calledSet.has(n);
          cell.className = "tcell" + (isCalled ? " called" : "");
          cell.textContent = n;

          if (canEdit) {
            cell.style.cursor = "pointer";
            cell.addEventListener("click", () => {
              if (marked.has(idx)) marked.delete(idx);
              else marked.add(idx);
              saveTicketLocal();
              renderMyTicket(game, me, calledSet);
            });
          }

          ticketEl.appendChild(cell);
        });

        winMsg.textContent = `Lu·∫≠t KINH: ƒë·ªß 1 h√†ng ngang (${cols} s·ªë) theo s·ªë ƒë√£ k√™u.`;
      }

      /* ===== Winner overlay ===== */
      function showWinner(winner) {
        winnerNameEl.textContent = winner?.name
          ? `Ng∆∞·ªùi ‚ÄúKINH‚Äù: ${winner.name}`
          : "Ng∆∞·ªùi ‚ÄúKINH‚Äù: ‚Äî";
        winnerOverlay.style.display = "flex";
      }
      function hideWinner() {
        winnerOverlay.style.display = "none";
      }

      /* ===== All tickets viewer (ch·ªâ cho ng∆∞·ªùi ch∆∞a c√≥ v√© h·ª£p l·ªá) ===== */
      function renderAllTicketsIfNeeded(
        game,
        playersObj,
        calledSet,
        meHasValid,
      ) {
        if (meHasValid) {
          allTicketsPanel.style.display = "none";
          allTicketsEl.innerHTML = "";
          return;
        }

        allTicketsPanel.style.display = "block";
        const rows = game.ticketRows || 5;
        const cols = game.ticketCols || 5;
        const roundId = game.roundId || 0;
        const phase = game.phase || "waiting";

        const players = playersObj ? Object.values(playersObj) : [];
        const list = players
          .filter((p) => p && p.name)
          .sort((a, b) => (a.joinedAt || 0) - (b.joinedAt || 0));

        const validCount = list.filter((p) =>
          isValidTicketForRound(p, game),
        ).length;
        allTicketsHint.textContent = `Round ${roundId} ‚Ä¢ ${rows}x${cols} ‚Ä¢ Tr·∫°ng th√°i: ${phase.toUpperCase()} ‚Ä¢ V√© h·ª£p l·ªá: ${validCount}/${list.length}`;

        allTicketsEl.innerHTML = "";
        list.forEach((p) => {
          const card = document.createElement("div");
          card.className = "pCard";

          const head = document.createElement("div");
          head.className = "pHead";
          head.innerHTML = `
      <div class="pName">${p.name}${p.id === game.mcPlayerId ? " (MC)" : ""}</div>
      <div>${isValidTicketForRound(p, game) ? "V√© h·ª£p l·ªá" : "Ch∆∞a c√≥ v√©"}</div>
    `;
          card.appendChild(head);

          if (isValidTicketForRound(p, game)) {
            const grid = document.createElement("div");
            grid.className = "ticket";
            grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

            p.ticket.forEach((n) => {
              const cell = document.createElement("div");
              cell.className = "tcell" + (calledSet.has(n) ? " called" : "");
              cell.textContent = n;
              grid.appendChild(cell);
            });
            card.appendChild(grid);
          } else {
            const note = document.createElement("div");
            note.className = "small";
            note.textContent = "Kh√¥ng c√≥ v√© h·ª£p l·ªá cho v√°n n√†y.";
            card.appendChild(note);
          }

          allTicketsEl.appendChild(card);
        });
      }

      /* ===== Presence / register ===== */
      async function registerPlayer() {
        const name = (nameInput.value || "").trim();
        if (!name) {
          alert("B·∫°n c·∫ßn nh·∫≠p T√™n c·ªßa b·∫°n.");
          return false;
        }

        playerRef = db.ref(`rooms/${roomId}/players/${playerId}`);
        try {
          playerRef.onDisconnect().remove();
        } catch {}

        const now = Date.now();
        await playerRef.update({
          id: playerId,
          name,
          joinedAt: now,
          lastSeenAt: now,
        });

        if (heartbeatTimer) clearInterval(heartbeatTimer);
        heartbeatTimer = setInterval(() => {
          if (playerRef) playerRef.update({ lastSeenAt: Date.now() });
        }, 15000);

        loadTicketLocal();
        return true;
      }

      async function unregisterPlayer() {
        if (heartbeatTimer) {
          clearInterval(heartbeatTimer);
          heartbeatTimer = null;
        }
        if (playerRef) {
          try {
            await playerRef.remove();
          } catch {}
          playerRef = null;
        }
      }

      /* ===== Room init ===== */
      function ensureRoomStructure() {
        const now = Date.now();
        return roomRef.transaction((cur) => {
          if (cur === null) {
            return {
              createdAt: now,
              game: {
                roundId: now,
                phase: "waiting",
                mcPlayerId: null,
                ticketRows: 5,
                ticketCols: 5,
                called: [],
                last: null,
                locked: false,
                winner: null,
                updatedAt: now,
              },
              players: {},
            };
          }
          if (!cur.game) {
            cur.game = {
              roundId: now,
              phase: "waiting",
              mcPlayerId: null,
              ticketRows: 5,
              ticketCols: 5,
              called: [],
              last: null,
              locked: false,
              winner: null,
              updatedAt: now,
            };
          }
          if (cur.game.roundId === undefined) cur.game.roundId = now;
          if (cur.game.phase === undefined) cur.game.phase = "waiting";
          if (cur.game.ticketRows === undefined) cur.game.ticketRows = 5;
          if (cur.game.ticketCols === undefined) cur.game.ticketCols = 5;
          if (cur.players === undefined) cur.players = {};
          return cur;
        });
      }

      /* ===== MC rights ===== */
      function claimMC() {
        return roomRef.transaction((room) => {
          if (!room) return room;
          if (!room.game) room.game = {};
          if (!room.players) room.players = {};

          const mcId = room.game.mcPlayerId || null;
          const now = Date.now();
          const mcMissing = mcId && !room.players[mcId];
          const mcLastSeen =
            mcId && room.players[mcId]?.lastSeenAt
              ? room.players[mcId].lastSeenAt
              : 0;
          const mcStale = mcId && mcLastSeen && now - mcLastSeen > 45000;
          const canTakeover = !mcId || mcMissing || mcStale;
          if (!canTakeover) return;

          room.game.mcPlayerId = playerId;
          room.game.updatedAt = now;
          return room;
        });
      }
      function releaseMC() {
        return roomRef.transaction((room) => {
          if (!room || !room.game) return room;
          if (room.game.mcPlayerId !== playerId) return;
          room.game.mcPlayerId = null;
          room.game.updatedAt = Date.now();
          return room;
        });
      }
      function transferMC(toId) {
        return roomRef.transaction((room) => {
          if (!room || !room.game || !room.players) return room;
          if (room.game.mcPlayerId !== playerId) return;
          if (!toId || !room.players[toId]) return;
          room.game.mcPlayerId = toId;
          room.game.updatedAt = Date.now();
          return room;
        });
      }

      /* ===== Game actions ===== */
      function setTicketSize(rows, cols) {
        const gameRef = db.ref(`rooms/${roomId}/game`);
        return gameRef.transaction((game) => {
          if (!game) return game;
          if (game.mcPlayerId !== playerId) return game;
          if (game.phase !== "waiting") return game;
          game.ticketRows = rows;
          game.ticketCols = cols;
          game.updatedAt = Date.now();
          return game;
        });
      }

      function startNewRoundWaiting() {
        const gameRef = db.ref(`rooms/${roomId}/game`);
        return gameRef.transaction((game) => {
          if (!game) return game;
          if (game.mcPlayerId && game.mcPlayerId !== playerId) return game;

          if (!game.mcPlayerId) game.mcPlayerId = playerId;

          const now = Date.now();
          game.roundId = now;
          game.phase = "waiting";
          game.called = [];
          game.last = null;
          game.locked = false;
          game.winner = null;
          game.updatedAt = now;
          return game;
        });
      }

      function startPlay() {
        const gameRef = db.ref(`rooms/${roomId}/game`);
        return gameRef.transaction((game) => {
          if (!game) return game;
          if (game.mcPlayerId !== playerId) return game;
          if (game.phase !== "waiting") return game;

          game.phase = "playing";
          game.called = [];
          game.last = null;
          game.locked = false;
          game.winner = null;
          game.updatedAt = Date.now();
          return game;
        });
      }

      function drawNumber() {
        const gameRef = db.ref(`rooms/${roomId}/game`);
        return gameRef.transaction((game) => {
          if (!game) return game;
          if (game.mcPlayerId !== playerId) return game;
          if (game.phase !== "playing") return game;
          if (game.locked || game.winner) return game;

          const called = Array.isArray(game.called) ? game.called.slice() : [];
          if (called.length >= 90) return game;

          const used = new Set(called);
          const remaining = [];
          for (let i = 1; i <= 90; i++) if (!used.has(i)) remaining.push(i);
          const n = remaining[Math.floor(Math.random() * remaining.length)];

          called.push(n);
          game.called = called;
          game.last = n;
          game.updatedAt = Date.now();
          return game;
        });
      }

      function undoNumber() {
        const gameRef = db.ref(`rooms/${roomId}/game`);
        return gameRef.transaction((game) => {
          if (!game) return game;
          if (game.mcPlayerId !== playerId) return game;
          if (game.phase !== "playing") return game;
          if (game.locked || game.winner) return game;

          const called = Array.isArray(game.called) ? game.called.slice() : [];
          called.pop();
          game.called = called;
          game.last = called.length ? called[called.length - 1] : null;
          game.updatedAt = Date.now();
          return game;
        });
      }

      function toggleLock(locked) {
        const gameRef = db.ref(`rooms/${roomId}/game`);
        return gameRef.transaction((game) => {
          if (!game) return game;
          if (game.mcPlayerId !== playerId) return game;
          if (game.phase !== "playing") return game;
          if (game.winner) return game;
          game.locked = !!locked;
          game.updatedAt = Date.now();
          return game;
        });
      }

      function resetRoom() {
        return db.ref(`rooms/${roomId}`).remove();
      }

      function claimWin(name) {
        const gameRef = db.ref(`rooms/${roomId}/game`);
        return gameRef.transaction((game) => {
          if (!game) return game;
          if (game.phase !== "playing") return game;
          if (game.locked || game.winner) return game;

          game.winner = { playerId, name, at: Date.now() };
          game.phase = "ended";
          game.locked = true;
          game.updatedAt = Date.now();
          return game;
        });
      }

      /* ===== UI helpers ===== */
      function getPlayerName(playersObj, pid) {
        return playersObj && pid && playersObj[pid] && playersObj[pid].name
          ? playersObj[pid].name
          : "‚Äî";
      }

      function renderPlayersList(playersObj, mcId) {
        const players = playersObj ? Object.values(playersObj) : [];
        const list = players
          .filter((p) => p && p.name)
          .sort((a, b) => (a.joinedAt || 0) - (b.joinedAt || 0));
        playersPill.textContent = `Ng∆∞·ªùi ch∆°i: ${list.length}`;

        if (!list.length) {
          playersListEl.textContent = "‚Äî";
          return;
        }
        playersListEl.textContent = list
          .map((p) => `‚Ä¢ ${p.name}${p.id === mcId ? " (MC)" : ""}`)
          .join("\n");
        playersListEl.style.whiteSpace = "pre-line";

        if (isMC) {
          transferWrap.style.display = list.length >= 2 ? "block" : "none";
          transferTo.innerHTML = "";
          list
            .filter((p) => p.id !== playerId)
            .forEach((p) => {
              const opt = document.createElement("option");
              opt.value = p.id;
              opt.textContent = p.name;
              transferTo.appendChild(opt);
            });
        } else {
          transferWrap.style.display = "none";
        }
      }

      function phaseLabel(phase) {
        if (phase === "waiting") return "CH·ªú";
        if (phase === "playing") return "ƒêANG CH∆†I";
        if (phase === "ended") return "ƒê√É KINH";
        return "‚Äî";
      }

      function updateUIState(game, playersObj, me) {
        const mcId = game?.mcPlayerId || null;
        isMC = mcId === playerId;

        const meHasValid = isValidTicketForRound(me, game);
        const role = isMC
          ? meHasValid
            ? "mcplayer"
            : "mc"
          : meHasValid
            ? "player"
            : "viewer";
        // ·∫®N khu v·ª±c MC n·∫øu: ng∆∞·ªùi ch∆°i b√¨nh th∆∞·ªùng (kh√¥ng ph·∫£i MC) + ph√≤ng ƒë√£ c√≥ MC
        const shouldHideMCSection = !isMC && !!mcId;
        if (mcSection)
          mcSection.style.display = shouldHideMCSection ? "none" : "block";

        document.body.classList.remove(
          "role-player",
          "role-mc",
          "role-viewer",
          "role-mcplayer",
        );
        document.body.classList.add("role-" + role);
        rolePill.textContent =
          "Vai tr√≤: " +
          (role === "mcplayer"
            ? "MC (c√≥ ch∆°i)"
            : role === "mc"
              ? "MC"
              : role === "player"
                ? "Ng∆∞·ªùi ch∆°i"
                : "Ng∆∞·ªùi xem");

        const now = Date.now();
        const mcLastSeen =
          mcId && playersObj?.[mcId]?.lastSeenAt
            ? playersObj[mcId].lastSeenAt
            : 0;
        const mcMissing = mcId && !playersObj?.[mcId];
        const mcStale = mcId && mcLastSeen && now - mcLastSeen > 45000;
        const canTakeover = !mcId || mcMissing || mcStale;

        const mcName = mcId ? getPlayerName(playersObj, mcId) : "Ch∆∞a c√≥";
        mcInfo.textContent = `MC: ${mcName}${isMC ? " (B·∫°n)" : ""}${!mcId ? "" : mcMissing ? " ‚Ä¢ (ƒë√£ r·ªùi)" : mcStale ? " ‚Ä¢ (m·∫•t k·∫øt n·ªëi)" : ""}`;

        btnClaimMC.disabled = !roomId || isMC || !canTakeover;
        btnReleaseMC.disabled = !roomId || !isMC;

        const phase = game.phase || "waiting";
        const hasWinner = !!game.winner;
        const locked = !!game.locked;

        phasePill.textContent = `Tr·∫°ng th√°i: ${phaseLabel(phase)}`;
        phaseMini.textContent = `${phaseLabel(phase)} ‚Ä¢ Round ${game.roundId || 0}`;

        lockPill.style.display = locked ? "inline-flex" : "none";
        chkLock.checked = locked;

        const rows = game.ticketRows || 5;
        const cols = game.ticketCols || 5;
        ticketSizeSel.value = `${rows}x${cols}`;
        ticketSizeSel.disabled = !roomId || !isMC || phase !== "waiting";

        btnNewRound.disabled = !roomId || (!!mcId && !isMC);
        btnStartPlay.disabled = !roomId || !isMC || phase !== "waiting";
        btnDraw.disabled =
          !roomId || !isMC || phase !== "playing" || locked || hasWinner;
        btnUndo.disabled =
          !roomId || !isMC || phase !== "playing" || locked || hasWinner;
        btnResetRoom.disabled = !roomId || !isMC;
        chkLock.disabled = !roomId || !isMC || phase !== "playing" || hasWinner;

        chkAuto.disabled = !roomId || !isMC;
        autoSec.disabled = !roomId || !isMC;
        slowExtraSec.disabled = !roomId || !isMC;

        const showQuick = roomId && phase === "ended" && isMC;
        mcQuickBar.style.display = showQuick ? "flex" : "none";

        btnOverlayNewRound.disabled = !roomId || !isMC;

        btnNewTicket.disabled = !roomId || phase !== "waiting";
        btnClearMarks.disabled = !roomId || phase !== "waiting" || !meHasValid;

        if (phase === "waiting") {
          phaseHint.innerHTML = `Tr·∫°ng th√°i <b>CH·ªú</b>: m·ªçi ng∆∞·ªùi c√≥ th·ªÉ t·∫°o/ƒë·ªïi v√©. MC ch·ªçn k√≠ch th∆∞·ªõc (5x5 ho·∫∑c 9x5) r·ªìi b·∫•m <b>B·∫Øt ƒë·∫ßu ch∆°i</b>.`;
        } else if (phase === "playing") {
          phaseHint.innerHTML = `Tr·∫°ng th√°i <b>ƒêANG CH∆†I</b>: kh√¥ng ƒë·ªïi v√©. N·∫øu b·∫°n c√≥ v√© h·ª£p l·ªá th√¨ ch·ªâ th·∫•y v√© c·ªßa m√¨nh.`;
        } else if (phase === "ended") {
          phaseHint.innerHTML = `Tr·∫°ng th√°i <b>ƒê√É KINH</b>: v√°n d·ª´ng. MC b·∫•m <b>B·∫Øt ƒë·∫ßu v√°n m·ªõi</b> ƒë·ªÉ chuy·ªÉn v·ªÅ CH·ªú.`;
        } else {
          phaseHint.textContent = "‚Äî";
        }

        return meHasValid;
      }

      /* ===== Room sync ===== */
      function onRoomUpdate(snapshot) {
        const data = snapshot.val();
        if (!data) {
          setConnectedUI(false, "Ph√≤ng ƒë√£ b·ªã xo√°");
          roomInfo.textContent = "";
          lastNumValue.textContent = "‚Äî";
          countPill.textContent = "ƒê√£ k√™u: 0/90";
          playersPill.textContent = "Ng∆∞·ªùi ch∆°i: 0";
          playersListEl.textContent = "‚Äî";
          mcInfo.textContent = "Ch∆∞a v√†o ph√≤ng";
          allTicketsPanel.style.display = "none";
          mcQuickBar.style.display = "none";
          hideWinner();
          renderBoard(new Set(), null);
          renderHistory([]);
          ticketWrap.style.display = "none";
          return;
        }

        const game = data.game || {};
        const playersObj = data.players || {};
        const me = playersObj[playerId] || null;

        const calledArr = Array.isArray(game.called) ? game.called : [];
        const calledSet = new Set(calledArr);
        const last = typeof game.last === "number" ? game.last : null;
        const nearWin = anyPlayerNearWin(game, playersObj, calledSet);
        const bigBox = $("bigBox");

        // UI state
        const meHasValid = updateUIState(game, playersObj, me);

        // info
        const rows = game.ticketRows || 5;
        const cols = game.ticketCols || 5;
        roomInfo.innerHTML = `
    <div>M√£ ph√≤ng: <span class="mono"><b>${roomId}</b></span></div>
    <div>Round: <b>${game.roundId || 0}</b> ‚Ä¢ V√©: <b>${rows}x${cols}</b> ‚Ä¢ C·∫≠p nh·∫≠t: ${game.updatedAt ? new Date(game.updatedAt).toLocaleString("vi-VN") : "‚Äî"}</div>
  `;

        renderPlayersList(playersObj, game.mcPlayerId || null);

        // main board
        lastNumValue.textContent = last ? String(last).padStart(2, "0") : "‚Äî";
        countPill.textContent = `ƒê√£ k√™u: ${calledArr.length}/90`;
        renderBoard(calledSet, last);
        renderHistory(calledArr);

        // hi·ªáu ·ª©ng khi c√≥ s·ªë m·ªõi
        if (last) {
          const suspense = nearWin && game.phase === "playing" && !game.winner;

          if (suspense) {
            startDiceRoll(last, 1400);
          } else {
            bigBox.classList.remove("roll");
            void bigBox.offsetWidth;
            bigBox.classList.add("roll");
            setTimeout(() => bigBox.classList.remove("roll"), 650);
          }
        }

        // overlay + danh s√°ch ng∆∞·ªùi c√≥ v√© (ch∆∞a KINH)
        if (game.winner) {
          showWinner(game.winner);
          const list = playersObj ? Object.values(playersObj) : [];
          const valid = list
            .filter((p) => p && p.name && isValidTicketForRound(p, game))
            .filter((p) => p.id !== game.winner.playerId)
            .sort((a, b) => (a.joinedAt || 0) - (b.joinedAt || 0));
          nonWinnerListEl.textContent = valid.length
            ? valid.map((p) => `‚Ä¢ ${p.name} (${rows}x${cols})`).join("\n")
            : "‚Äî";
        } else {
          hideWinner();
          nonWinnerListEl.textContent = "‚Äî";
        }

        // render my ticket
        renderMyTicket(game, me, calledSet);

        // Only show all tickets to users without valid ticket
        renderAllTicketsIfNeeded(game, playersObj, calledSet, meHasValid);

        // ‚Äúƒê·ª£i‚Äù (c√≥ ng∆∞·ªùi g·∫ßn KINH)
        waitPill.style.display =
          nearWin && game.phase === "playing" && !game.winner
            ? "inline-flex"
            : "none";

        // b·∫≠t/t·∫Øt giao di·ªán "x√≠ ng·∫ßu" khi c√≥ ng∆∞·ªùi ƒê·ª£i
        if (nearWin && game.phase === "playing" && !game.winner)
          bigBox.classList.add("dice");
        else {
          bigBox.classList.remove("dice");
          bigBox.classList.remove("rolling");
          if (diceTimer) {
            clearInterval(diceTimer);
            diceTimer = null;
          }
        }

        // Auto k√™u s·ªë (ch·ªâ MC)
        scheduleAutoDraw(game, playersObj, calledSet);

        // MC speak
        if (isMC && chkSpeak.checked && last && !game.winner) {
          const key = `${game.roundId || 0}|${last}|${game.updatedAt || 0}`;
          if (key !== lastSpokenKey) {
            lastSpokenKey = key;
            speak(`S·ªë ${last}. ${readNumberVN(last)}.`);
          }
        }
        if (
          isMC &&
          chkSpeak.checked &&
          game.winner?.at &&
          game.winner.at !== lastWinSpokenAt
        ) {
          lastWinSpokenAt = game.winner.at;
          speak(`Kinh! ${game.winner.name || "c√≥ ng∆∞·ªùi kinh"}.`);
        }

        // Auto claim win: ch·ªâ khi PLAYING + c√≥ v√© h·ª£p l·ªá
        if (
          game.phase === "playing" &&
          !game.winner &&
          !game.locked &&
          meHasValid
        ) {
          const t = me.ticket;
          if (hasAnyFullRow(t, rows, cols, calledSet)) {
            const name = (nameInput.value || "").trim() || "Kh√¥ng t√™n";
            claimWin(name);
          }
        }
      }

      function attachRoom(rid) {
        roomRef = db.ref("rooms/" + rid);
        roomRef.on("value", onRoomUpdate);
      }
      function detachRoom() {
        if (roomRef) roomRef.off();
        roomRef = null;
      }

      /* ===== UI events ===== */
      btnCreate.addEventListener(
        "click",
        () => (roomInput.value = genRoomId()),
      );

      btnJoin.addEventListener("click", async () => {
        if (!safeInitFirebase()) return;

        roomId = roomInput.value.trim();
        if (!roomId) return alert("Nh·∫≠p M√£ ph√≤ng tr∆∞·ªõc.");
        if (!(nameInput.value || "").trim())
          return alert("Nh·∫≠p T√™n c·ªßa b·∫°n tr∆∞·ªõc.");

        btnJoin.disabled = true;
        btnLeave.disabled = false;
        roomInput.disabled = true;
        btnCreate.disabled = true;
        nameInput.disabled = true;

        setConnectedUI(true, "ƒêang k·∫øt n·ªëi‚Ä¶");

        detachRoom();
        attachRoom(roomId);
        await ensureRoomStructure();

        const ok = await registerPlayer();
        if (!ok) {
          btnLeave.click();
          return;
        }

        setConnectedUI(true, "ƒê√£ v√†o ph√≤ng");
      });

      btnLeave.addEventListener("click", async () => {
        hideWinner();
        detachRoom();
        await unregisterPlayer();

        setConnectedUI(false, "ƒê√£ r·ªùi ph√≤ng");

        roomInfo.textContent = "";
        lastNumValue.textContent = "‚Äî";
        countPill.textContent = "ƒê√£ k√™u: 0/90";
        phasePill.textContent = "Tr·∫°ng th√°i: ‚Äî";
        rolePill.textContent = "Vai tr√≤: ‚Äî";
        playersPill.textContent = "Ng∆∞·ªùi ch∆°i: 0";
        playersListEl.textContent = "‚Äî";
        mcInfo.textContent = "Ch∆∞a v√†o ph√≤ng";
        phaseMini.textContent = "‚Äî";
        phaseHint.textContent = "‚Äî";

        allTicketsPanel.style.display = "none";
        allTicketsEl.innerHTML = "";
        mcQuickBar.style.display = "none";
        ticketWrap.style.display = "none";

        roomInput.disabled = false;
        btnCreate.disabled = false;
        btnJoin.disabled = false;
        btnLeave.disabled = true;
        nameInput.disabled = false;

        roomId = "";
        document.body.classList.remove(
          "role-player",
          "role-mc",
          "role-viewer",
          "role-mcplayer",
        );
      });

      btnClaimMC.addEventListener("click", async () => {
        if (roomId) await claimMC();
      });
      btnReleaseMC.addEventListener("click", async () => {
        if (roomId) await releaseMC();
      });
      btnTransferMC.addEventListener("click", async () => {
        if (roomId) await transferMC(transferTo.value);
      });

      ticketSizeSel.addEventListener("change", async () => {
        if (!roomId || !isMC) return;
        const v = ticketSizeSel.value;
        const [r, c] = v.split("x").map(Number);
        await setTicketSize(r, c);
      });

      btnNewRound.addEventListener("click", async () => {
        if (roomId) await startNewRoundWaiting();
      });
      btnQuickNewRound.addEventListener("click", async () => {
        if (roomId) await startNewRoundWaiting();
      });
      btnOverlayNewRound.addEventListener("click", async () => {
        if (roomId && isMC) await startNewRoundWaiting();
      });
      btnOverlayClose.addEventListener("click", () => hideWinner());

      btnStartPlay.addEventListener("click", async () => {
        if (roomId) await startPlay();
      });
      btnDraw.addEventListener("click", async () => {
        if (roomId) await drawNumber();
      });
      btnUndo.addEventListener("click", async () => {
        if (roomId) await undoNumber();
      });

      chkLock.addEventListener("change", async () => {
        if (roomId) await toggleLock(chkLock.checked);
      });

      function touchAutoPlan() {
        autoPlanKey = "";
        clearAutoTimer();
      }
      chkAuto.addEventListener("change", () => touchAutoPlan());
      autoSec.addEventListener("change", () => touchAutoPlan());
      slowExtraSec.addEventListener("change", () => touchAutoPlan());

      btnResetRoom.addEventListener("click", async () => {
        if (!roomId) return;
        if (!confirm("Xo√° ph√≤ng s·∫Ω l√†m m·ªçi ng∆∞·ªùi b·ªã ng·∫Øt. B·∫°n ch·∫Øc ch·∫Øn?"))
          return;
        await resetRoom();
      });

      btnNewTicket.addEventListener("click", async () => {
        if (!roomId) return;
        const [rows, cols] = ticketSizeSel.value.split("x").map(Number);

        const snap = await db.ref(`rooms/${roomId}/game`).once("value");
        const game = snap.val();
        if (!game || game.phase !== "waiting")
          return alert("Ch·ªâ t·∫°o/ƒë·ªïi v√© khi ƒëang CH·ªú.");

        const meta = {
          roundId: game.roundId,
          rows: game.ticketRows || rows,
          cols: game.ticketCols || cols,
        };
        const t = generateTicket(meta.rows, meta.cols);

        localTicket.ticket = t;
        localTicket.meta = meta;
        marked = new Set();
        saveTicketLocal();

        await saveTicketToDB(t, meta);
      });

      btnClearMarks.addEventListener("click", () => {
        marked = new Set();
        saveTicketLocal();
      });

      /* init */
      renderBoard(new Set(), null);
      renderHistory([]);
    </script>
  </body>
</html>
